## IO模型

IO读会经历两个阶段，等待数据准备和将数据从内核拷贝到用户空间。

### 阻塞IO

当进程开始调用recvfrom，内核开始第一阶段：准备数据。而进程此时会被阻塞，当数据就绪后,内核会将数据拷贝到用户空间，然后返回成功，用户进程解除阻塞，重新运行。

![阻塞IO](/images/阻塞IO.png)

### 非阻塞IO

当用户进程发起recvfrom调用时，如果内核中数据还没准备好，则不会阻塞用户进程，而是返回error。从用户进程的角度来讲，发起read操作后并不需要阻塞，而是会马上得到一个结果，当用户进程接受的结果时error时，它就知道是数据还没准备好，则会再次发起read，询问数据是否准备好，如果内核数据准备好了，而且这时用户进程再次发起read,则内核会把数据拷贝到用户空间。

![非阻塞IO](/images/非阻塞IO.png)

### 多路复用IO

为了减少非阻塞模型轮询花费的CPU时间，可以将一个或多个fd(文件句柄)传递给select/epoll进行系统调用，阻塞在select操作上，select可以监测到一个或多个fd的就绪状态，当fd可读时，返回给用户进程进行recvfrom调用。

多路复用和非阻塞模型的区别在于前者select是内核级别的，select可以监听多个socket。

![多路复用IO](/images/多路复用IO.png)

### 信号驱动IO

用户进程建立SIGIO信号处理程序，发送sigaction系统调用，内核返回，然后用户进程继续执行，内核数据准备完毕，发送SIGIO信号，用户程序收到信号后在信号处理程序发送recvfrom系统调用，内核将数据从内核复制到用户空间，然后返回成功指示。

![信号驱动IO](/images/信号驱动IO.png)

### 异步IO    


